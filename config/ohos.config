# This file contains the default configuration to compile for OpenHarmony
# platforms. It contains sensitive enviroment configuration that
# shouldn't be modified unless you know what you are doing.
# PLEASE, DO NOT EDIT THIS FILE

import os
from cerbero.enums import Architecture, DistroVersion, Platform
from cerbero.errors import FatalError
import cerbero.utils.messages as m

# So, paths:
#
# toolchain_prefix: SDK location
# toolchain_path: location of the compiler binaries
# sysroot: location of the API-level libraries (no headers)
# isysroot: location of the headers

variants.override(['nopython', 'notestspackage', 'rust'])

# We don't want anything from linux system to be used on android :)
allow_system_libs=False

if not toolchain_prefix:
    toolchain_prefix = os.path.join(home_dir, 'ohos-sdk')

toolchain_path = None
toolchain_version = None

v = DistroVersion.get_ohos_api_version(target_distro_version)

tools_prefix = None
tools_dir = None
host = None
llvm_triple = None

if target_arch == Architecture.ARM64:
  tools_prefix = 'aarch64-linux-ohos'
  tools_dir = tools_prefix
  arch_include = tools_prefix
  host = 'aarch64-linux-ohos'
  llvm_triple = 'aarch64-linux-ohos'
  _ohos_arch = 'arm64'
  _cerbero_arch = 'arm64'
  _cxx_arch = 'arm64-v8a'
else:
  raise FatalError(f'Arch {target_arch} not supported')

llvm_toolchain_path = f'{toolchain_prefix}/{v}/native/llvm/bin'

isysroot = f'{toolchain_prefix}/{v}/native/sysroot'
sysroot = f'{toolchain_prefix}/{v}/native/sysroot'

# Default compiler flags
env['CFLAGS'] = ''
env['CXXFLAGS'] = ''
env['OBJCFLAGS'] = ''

# Make sure user's env doesn't mess up with our build.
env.pop('RUSTFLAGS', None)

# OpenHarmony SDK native path. These are the same variables OHOS SDK CMake toolchain uses.
env['OHOS_SDK_NATIVE'] = f'{toolchain_prefix}/{v}/native'
env['OHOS_SDK_NATIVE_TOOLCHAIN_BIN'] = llvm_toolchain_path

incl_dir = os.path.join(prefix, 'include')
lib_dir = os.path.join(prefix, 'lib')

ccache = use_ccache and 'ccache ' or ''
# __MULS__ is need to prevent double definition of
# struct sockaddr_storage in OHOS sysroot (userspace and kernel header gets mixed)
defines = f'-DOHOS -D__OHOS__ -D__MUSL__ -DPIC '

cflags = f'-target {llvm_triple} --sysroot {sysroot} -isysroot {isysroot} -isystem {incl_dir} -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -fPIC -Wno-invalid-command-line-argument -Wno-unused-command-line-argument '
ldflags = f'-fPIC -no-canonical-prefixes -Wl,-no-undefined -Wl,-z,noexecstack -Wl,-z,relro -Wl,-z,now -Wl,--gc-sections -Wl,--warn-shared-textrel,--undefined-version '

ldflags += ' -L' + lib_dir

# Initialize both the linker and the sysroot
ldflags += f' -L{sysroot}/usr/lib/{host}/{v} -Wl,--sysroot={sysroot}'

ldvariant = 'lld'
ldflags += f' -fuse-ld={ldvariant} '

# Toolchain environment
env['CPPFLAGS'] = defines
env['CFLAGS'] += f'{cflags} {defines} -Wa,--noexecstack'
env['CXXFLAGS'] = env['CFLAGS'] + ' -fno-rtti -fno-exceptions '
env['LDFLAGS'] = ldflags

def llvm_cmd(command):
    return os.path.join(llvm_toolchain_path, command)

# clang requires the full path otherwise it does stupid things and can't
# find it's own binary
env['CC']= ccache + llvm_cmd('clang') + f' -target {llvm_triple}' + f' --sysroot {sysroot}'
env['CC_FOR_BUILD']= ccache + llvm_cmd('clang')
env['CXX']= ccache + llvm_cmd('clang++') + f' -target {llvm_triple}' + f' --sysroot {sysroot}'

# linker is needed for Autotools
env['LD']= llvm_cmd(f'ld.lld')

# Supply the linker separately to pick up the dependency on -lunwind
env['RUSTC_LINKER']= llvm_cmd(f'{llvm_triple}-clang')
env['CPP']= llvm_cmd('clang') + ' -E'
env['RANLIB']= llvm_cmd('llvm-ranlib')
env['AR']= llvm_cmd('llvm-ar')
env['AS']= llvm_cmd('llvm-as')
env['NM']= llvm_cmd('llvm-nm')
env['STRIP']= llvm_cmd('llvm-strip')
env['OBJCOPY']= llvm_cmd('llvm-objcopy')

